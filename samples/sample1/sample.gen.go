// generated by ella compiler; DO NOT EDIT

package main

//
// Imports
//

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"strings"
	"time"

	"ella.to/sse"
)

func init() {
	_ = time.Time{}
	if sse.Version < "0.0.7" {
		panic("ella.to/sse version must be at least v0.0.7")
	}
}

//
// Constants
//

const A = 1

//
// Enums
//

type Role int8

const (
	Role_User Role = 0
	Role_Root Role = 1
)

func (e *Role) UnmarshalText(text []byte) error {
	switch strings.ToLower(string(text)) {
	case "user":
		*e = Role_User
	case "root":
		*e = Role_Root
	default:
		return fmt.Errorf("invalid enum value: %s", string(text))
	}
	return nil
}

func (e Role) MarshalText() ([]byte, error) {
	name := e.String()
	if name == "" {
		return nil, fmt.Errorf("invalid enum Role value: %v", e)
	}
	return []byte(name), nil
}

func (e Role) String() string {
	var name string
	switch e {
	case Role_User:
		name = "user"
	case Role_Root:
		name = "root"
	default:
		name = ""
	}
	return name
}

//
// Models
//

type User struct {
	Id string `json:"id"`
	Value int64 `json:"value"`
}

//
// Http Services (1)
//

type HttpUserService interface {
	GetById(ctx context.Context, userId string) (result *User, err error)
	Upload(ctx context.Context, id string, files func() (filename string, content io.Reader, err error)) (err error)
}

//
// Rpc Services (0)
//

//
// Registry Http Services (1)
//

func RegisterHttpUserServiceServer(r Registererer, srv HttpUserService) {
	r.Register(
		"HttpUserService.GetById",
		process1(
			func(
				ctx context.Context,
				args struct {
					UserId string `json:"userId"`
				},
			) (
				*User,
				error,
			) {
				return srv.GetById(
					ctx,
					args.UserId,
				)
			},
		),
	)
	r.Register(
		"HttpUserService.Upload",
		processUpload0(
			func(
				ctx context.Context,
				args struct {Id string `json:"id"`
				},
				files func() (string, io.Reader, error),
			) (
				error,
			) {
				return srv.Upload(
					ctx,args.Id,
					files,
				)
			},
		),
	)	
	
}

//
// Registry Rpc Services (0)
//



//
// Custom Errors
//


// Default Errors

var (
	ErrUnsupportedMediaType  = newError(-1, http.StatusUnsupportedMediaType, "unsupported media type")
	ErrServiceMethodNotFound = newError(-2, http.StatusNotFound, "service method not found")
	ErrMissingFilesField     = newError(-3, http.StatusBadRequest, "missing files field")
	ErrMissingPayloadName    = newError(-4, http.StatusBadRequest, "missing payload field")
	ErrMethodNotAllowed      = newError(-5, http.StatusMethodNotAllowed, "method not allowed")
	ErrInternal 			 = newError(-6, http.StatusInternalServerError, "internal server error")
)

//
// Helper functions
//

//
// Context Key
//

type ctxKey string

const (
	ctxMetadataKey = ctxKey("ella:metadata")
)

type Metadata struct {
	ContentType      string
	FormDataBoundary string
	Id               string
	Method           string
	Params           json.RawMessage
	Files            []*multipart.Part
}

func MetaDataFromContext(ctx context.Context) *Metadata {
	meta, _ := ctx.Value(ctxMetadataKey).(*Metadata)
	return meta
}

// Http

type httpServiceMethodHandler func(context.Context, http.ResponseWriter, *http.Request)

// Error

type Error struct {
	Code    int64  `json:"code"`
	Message string `json:"message"`
	Status  int    `json:"status"`
	Cause   error  `json:"cause,omitempty"`
}

var _ error = (*Error)(nil)

func (e *Error) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("%d: %s: %v", e.Code, e.Message, e.Cause)
	}
	return fmt.Sprintf("%d: %s", e.Code, e.Message)
}

func (e Error) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(*Error); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.Cause, target)
}

func (e Error) Unwrap() error {
	return e.Cause
}

func (e Error) WithCause(cause error) *Error {
	err := e
	err.Cause = cause
	return &err
}

func (e Error) WithMsg(msg string, args ...any) *Error {
	err := e
	err.Message = fmt.Sprintf(msg, args...)
	return &err
}

func (e *Error) MarshalJSON() ([]byte, error) {
	payload := struct {
		Error struct {
			Code    int64  `json:"code"`
			Message string `json:"message"`
			Status  int    `json:"status"`
			Cause   string `json:"cause,omitempty"`
		} `json:"error"`
	}{}

	payload.Error.Code = e.Code
	payload.Error.Message = e.Message
	payload.Error.Status = e.Status
	if e.Cause != nil {
		payload.Error.Cause = e.Cause.Error()
	}

	return json.Marshal(payload)
}

func (e *Error) UnmarshalJSON(data []byte) error {
	wrapper := struct {
		Error json.RawMessage `json:"error"`
	}{}

	if err := json.Unmarshal(data, &wrapper); err != nil {
		return err
	}

	if bytes.Index(wrapper.Error, []byte("{")) == 0 {
		return json.Unmarshal(wrapper.Error, e)
	}

	e.Message = string(wrapper.Error)
	e.Code = 0
	e.Status = 500
	e.Cause = nil

	return nil
}

func newError(code int64, status int, format string, args ...any) *Error {
	return &Error{
		Code:    code,
		Message: fmt.Sprintf(format, args...),
		Status:  status,
	}
}

//
// Process Helpers
//

type request struct {
	Id     string          `json:"id"`
	Method string          `json:"method"`
	Params json.RawMessage `json:"params"`
}

type response struct {
	Id      string `json:"id"`
	Results []any  `json:"results"`
}

// NewHttpReceiver support only the following accept types
// - application/json (request/response json encoding)
// - text/event-stream (server-sent events)
// - application/octet-stream (raw binary data)
// - multipart/form-data (file uploads)
func NewHttpReceiver(recv Receiver) http.Handler {
	var supportedTypes = []string{
		"application/json",
		"text/event-stream",
		"application/octet-stream",
		"multipart/form-data",
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
			return
		}

		contentType := r.Header.Get("Content-Type")
		if contentType == "" {
			http.Error(w, "missing Content-Type header", http.StatusBadRequest)
			return
		}

		// quick and dirty check
		var supported bool
		for _, t := range supportedTypes {
			if strings.Contains(contentType, t) {
				supported = true
				break
			}
		}
		if !supported {
			http.Error(w, "unsupported Content-Type header", http.StatusNotAcceptable)
			return
		}

		meta := &Metadata{}

		ctx := context.WithValue(r.Context(), ctxMetadataKey, meta)

		switch contentType {
		case "application/json":
			{
				req := new(request)
				if err := json.NewDecoder(r.Body).Decode(req); err != nil {
					http.Error(w, err.Error(), http.StatusBadRequest)
					return
				}

				meta.Id = req.Id
				meta.Method = req.Method
				meta.Params = req.Params
			}
		case "multipart/form-data":
			{
				boundary := strings.TrimPrefix(contentType, "multipart/form-data; boundary=")
				if boundary == "" {
					http.Error(w, "missing boundary in Content-Type header", http.StatusBadRequest)
					return
				}
				meta.FormDataBoundary = boundary

				reader, err := r.MultipartReader()
				if err != nil {
					http.Error(w, err.Error(), http.StatusBadRequest)
					return
				}

				for {
					part, err := reader.NextPart()
					if errors.Is(err, io.EOF) {
						break
					} else if err != nil {
						http.Error(w, err.Error(), http.StatusInternalServerError)
						return
					}

					switch part.FormName() {
					case "id":
						{
							data, err := io.ReadAll(part)
							if err != nil {
								http.Error(w, err.Error(), http.StatusInternalServerError)
								return
							}

							meta.Id = string(data)
						}
					case "method":
						{
							data, err := io.ReadAll(part)
							if err != nil {
								http.Error(w, err.Error(), http.StatusInternalServerError)
								return
							}

							meta.Method = string(data)
						}
					case "params":
						{
							data, err := io.ReadAll(part)
							if err != nil {
								http.Error(w, err.Error(), http.StatusInternalServerError)
								return
							}

							meta.Params = data
						}
					case "file":
						{
							meta.Files = append(meta.Files, part)
						}
					default:
						{
							http.Error(w, "unknown form field", http.StatusBadRequest)
							return
						}
					}
				}
			}
		}

		recv.Receive(ctx, r.Body, w)
	})
}

type Registererer interface {
	Register(name string, recv Receiver)
}

type Registry struct {
	mapper map[string]Receiver
}

var _ Receiver = (*Registry)(nil)
var _ Registererer = (*Registry)(nil)

func (r *Registry) Receive(ctx context.Context, in io.Reader, out io.Writer) {
	meta := MetaDataFromContext(ctx)
	if meta == nil {
		return
	}

	recv, ok := r.mapper[meta.Method]
	if !ok {
		return
	}

	recv.Receive(ctx, in, out)
}

func (r *Registry) Register(name string, recv Receiver) {
	if _, ok := r.mapper[name]; ok {
		panic(fmt.Sprintf("receiver %q already registered", name))
	}
	r.mapper[name] = recv
}

func CreateRegistry() *Registry {
	return &Registry{
		mapper: make(map[string]Receiver),
	}
}

// Receiver

type Receiver interface {
	Receive(ctx context.Context, in io.Reader, out io.Writer)
}

type ReceiverFunc func(ctx context.Context, in io.Reader, out io.Writer)

func (f ReceiverFunc) Receive(ctx context.Context, in io.Reader, out io.Writer) {
	f(ctx, in, out)
}

// Dialer

type Dialer interface {
	Dial(ctx context.Context, req io.Reader) (resp io.Reader)
}

type DialerFunc func(ctx context.Context, req io.Reader) (resp io.Reader)

func (f DialerFunc) Dial(ctx context.Context, req io.Reader) (resp io.Reader) {
	return f(ctx, req)
}


func process0[A any](fn func(context.Context, A) (error)) Receiver {
	return ReceiverFunc(func(ctx context.Context, in io.Reader, out io.Writer) {
		var a A
		if err := json.NewDecoder(in).Decode(&a); err != nil {
			marshalError(out, err)
			return
		}

		marshalArray(out)(fn(ctx, a))
	})
}

func process1[A, R1 any](fn func(context.Context, A) (R1, error)) Receiver {
	return ReceiverFunc(func(ctx context.Context, in io.Reader, out io.Writer) {
		var a A
		if err := json.NewDecoder(in).Decode(&a); err != nil {
			marshalError(out, err)
			return
		}

		marshalArray(out)(fn(ctx, a))
	})
}

func processUpload0[A any](fn func(context.Context, A, func() (string, io.Reader, error)) (error)) Receiver {
	return ReceiverFunc(func(ctx context.Context, _ io.Reader, out io.Writer) {
		meta := MetaDataFromContext(ctx)
		if meta == nil {
			marshalError(out, errors.New("metadata not found"))
			return
		}

		idx := 0
		files := func() (string, io.Reader, error) {
			if idx >= len(meta.Files) {
				return "", nil, io.EOF
			}

			part := meta.Files[idx]
			idx++

			return part.FileName(), part, nil
		}

		var a A
		if err := json.Unmarshal(meta.Params, &a); err != nil {
			marshalError(out, err)
			return
		}

		marshalArray(out)(fn(ctx, a, files))
	})
}

func marshalError(out io.Writer, err error) error {
	return json.NewEncoder(out).Encode(err)
}

// last element in the array is error, if it's nil, it's a success
func marshalArray(out io.Writer) func(args ...any) {
	return func(args ...any) {
		if len(args) > 0 && args[len(args)-1] != nil {
			marshalError(out, args[len(args)-1].(error))
			return
		}

		json.NewEncoder(out).Encode(args)
	}
}