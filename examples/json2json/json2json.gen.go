// generated by ella compiler; DO NOT EDIT

package main

//
// Imports
//

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"strings"
	"time"

	"ella.to/sse"
)

const requiredSSEVersion = "0.0.8"

func init() {
	_ = time.Time{}
	if sse.Version < requiredSSEVersion {
		panic("ella.to/sse version must be at least v" + requiredSSEVersion)
	}
}

//
// Constants
//


//
// Enums
//

//
// Models
//

type User struct {
	Id string `json:"id"`
	Name string `json:"name"`
}

type Event struct {
	Id string `json:"id"`
}

//
// Http Services (1)
//

type HttpUserService interface {
	GetById(ctx context.Context, id string) (result *User, err error)
	UploadAvatar(ctx context.Context, userId string, file func() (filename string, content io.Reader, err error)) (err error)
	UploadFiles(ctx context.Context, userId string, files func() (filename string, content io.Reader, err error)) (status <-chan *Event, err error)
	CompressFiles(ctx context.Context, files func() (filename string, content io.Reader, err error)) (result io.Reader, err error)
	Download(ctx context.Context, id string) (result io.Reader, err error)
	Events(ctx context.Context, id string) (result <-chan *Event, err error)
}




type httpUserServiceClient struct {
	sender Sender
}

var _ HttpUserService = (*httpUserServiceClient)(nil)

func (c *httpUserServiceClient) GetById(ctx context.Context, id string) (result *User, err error) {
	params, err := json.Marshal(struct {
		Id string `json:"id"`
	}{
		Id: id,
	})
	if err != nil {
		return nil, err
	}

	req := &Request{
		Method: "HttpUserService.GetById",
		Params: params,
	}

	var buf bytes.Buffer
	c.sender.Send(ctx, req, &buf)

	var response struct {
		Result *User `json:"result"`
		Error  *Error `json:"error,omitempty"`
	}
	if err := json.NewDecoder(&buf).Decode(&response); err != nil {
		return nil, err
	}

	if response.Error != nil {
		return nil, response.Error
	}

	return response.Result, nil
}

func CreateRpcUserServiceClient(sender Sender) RpcUserService {
	return &httpUserServiceClient{}
}

//
// Rpc Services (1)
//

type RpcUserService interface {
	GetById(ctx context.Context, id string) (result *User, err error)
}



//
// Registry Http Services (1)
//

func RegisterHttpUserServiceServer(r Registererer, srv HttpUserService) {
	r.Register(
		"HttpUserService.GetById",
		handleJsonToJson1(
			func(
				ctx context.Context,
				args struct {
					Id string `json:"id"`
				},
			) (
				*User,
				error,
			) {
				return srv.GetById(
					ctx,
					args.Id,
				)
			},
		),
	)
	r.Register(
		"HttpUserService.UploadAvatar",
		handleBinaryToJson0(
			func(
				ctx context.Context,
				args struct {
					UserId string `json:"userId"`
				},
				file func() (string, io.Reader, error),
			) (
				error,
			) {
				return srv.UploadAvatar(
					ctx,
					args.UserId,
					file,
				)
			},
		),
	)
	r.Register(
		"HttpUserService.UploadFiles",
		handleBinaryToSSE(
			func(
				ctx context.Context,
				args struct {
					UserId string `json:"userId"`
				},
				files func() (string, io.Reader, error),
			) (
				<-chan *Event,
				error,
			) {
				return srv.UploadFiles(
					ctx,
					args.UserId,
					files,
				)
			},
		),
	)
	r.Register(
		"HttpUserService.CompressFiles",
		handleBinaryToBinary(
			func(
				ctx context.Context,
				args struct {
					
				},
				files func() (string, io.Reader, error),
			) (
				io.Reader, 
				error,
			) {
				return srv.CompressFiles(
					ctx,
					files,
				)
			},
		),
	)
	r.Register(
		"HttpUserService.Download",
		handleJsonToBinary(
			func(
				ctx context.Context,
				args struct {
					Id string `json:"id"`
				},
			) (
				io.Reader, 
				error,
			) {
				return srv.Download(
					ctx,
					args.Id,
				)
			},
		),
	)
	r.Register(
		"HttpUserService.Events",
		handleJsonToSSE(
			func(
				ctx context.Context,
				args struct {
					Id string `json:"id"`
				},
			) (
				<-chan *Event,
				error,
			) {
				return srv.Events(
					ctx,
					args.Id,
				)
			},
		),
	)
}

//
// Registry Rpc Services (1)
//

func RegisterRpcUserServiceServer(r Registererer, srv RpcUserService) {
	r.Register(
		"RpcUserService.GetById",
		handleJsonToJson1(
			func(
				ctx context.Context,
				args struct {
					Id string `json:"id"`
				},
			) (
				*User,
				error,
			) {
				return srv.GetById(
					ctx,
					args.Id,
				)
			},
		),
	)
}

//
// Custom Errors
//




type Request struct {
	Id          string            `json:"id"`
	Method      string            `json:"method"`
	Params      json.RawMessage   `json:"params"`
	ContentType string            `json:"-"`
	Files       []*multipart.Part `json:"-"`
	Boundary    string            `json:"-"`
}

type Sender interface {
	Send(ctx context.Context, req *Request, resp io.Writer)
}

type SenderFunc func(ctx context.Context, req *Request, resp io.Writer)

var _ Sender = (*SenderFunc)(nil)

func (f SenderFunc) Send(ctx context.Context, req *Request, resp io.Writer) {
	f(ctx, req, resp)
}

type Registererer interface {
	Register(name string, sender Sender)
}

//

type Registry struct {
	senders map[string]Sender
}

var (
	_ Registererer = (*Registry)(nil)
	_ Sender       = (*Registry)(nil)
)

func (r *Registry) Register(name string, sender Sender) {
	r.senders[name] = sender
}

func (r *Registry) Send(ctx context.Context, req *Request, resp io.Writer) {
	sender, ok := r.senders[req.Method]
	if !ok {
		writeError(resp, &Error{
			Code:    0,
			Message: "method not found",
		})
		return
	}
	sender.Send(ctx, req, resp)
}

func parseParams[A any](r io.Reader) (a A, err error) {
	err = json.NewDecoder(r).Decode(&a)
	return
}


func handleJsonToJson1[A, R1 any](fn func(context.Context, A) (R1, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		writeResults(resp)(fn(ctx, params))
	})
}



func handleJsonToBinary[A any](fn func(context.Context, A) (io.Reader, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		r, err := fn(ctx, params)
		if err != nil {
			writeError(resp, err)
			return
		}

		if w, ok := resp.(http.ResponseWriter); ok {
			w.WriteHeader(http.StatusOK)
			// TODO: change the content type later
			w.Header().Set("Content-Type", "application/octet-stream")
		}

		io.Copy(resp, r)
	})
}



func handleJsonToSSE[A, R any](fn func(context.Context, A) (<-chan R, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		var err error

		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		ch, err := fn(ctx, params)
		if err != nil {
			writeError(resp, err)
			return
		}

		streamEvents(ch, resp)
	})
}



func handleBinaryToJson0[A any](fn func(context.Context, A, func() (string, io.Reader, error)) (error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		idx := 0
		writeResults(resp)(fn(ctx, params, func() (string, io.Reader, error) {
			if idx >= len(req.Files) {
				return "", nil, io.EOF
			}

			part := req.Files[idx]
			idx++

			return part.FileName(), part, nil
		}))
	})
}



func handleBinaryToBinary[A any](fn func(context.Context, A, func() (string, io.Reader, error)) (io.Reader, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		idx := 0
		r, err := fn(ctx, params, func() (string, io.Reader, error) {
			if idx >= len(req.Files) {
				return "", nil, io.EOF
			}

			part := req.Files[idx]
			idx++

			return part.FileName(), part, nil
		})
		if err != nil {
			writeError(resp, err)
			return
		}

		if w, ok := resp.(http.ResponseWriter); ok {
			w.WriteHeader(http.StatusOK)
			// TODO: change the content type later
			w.Header().Set("Content-Type", "application/octet-stream")
		}

		io.Copy(resp, r)
	})
}



func handleBinaryToSSE[A, R any](fn func(context.Context, A, func() (string, io.Reader, error)) (<-chan R, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		var err error

		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			return
		}

		idx := 0
		ch, err := fn(ctx, params, func() (string, io.Reader, error) {
			if idx >= len(req.Files) {
				return "", nil, io.EOF
			}

			part := req.Files[idx]
			idx++

			return part.FileName(), part, nil
		})
		if err != nil {
			return
		}

		streamEvents(ch, resp)
	})
}



func streamEvents[T any](ch <-chan T, resp io.Writer) {
	var id int64
	pusher, err := sse.NewPusher(resp, 500*time.Millisecond)
	if err != nil {
		writeError(resp, err)
		return
	}

	defer func() {
		pusher.Close()
		id++

		if err != nil {
			var sb strings.Builder
			writeError(&sb, err)
			pusher.Push(sse.NewMessage(fmt.Sprintf("%d", id), "error", sb.String()))
			id++
		}

		pusher.Push(sse.NewMessage(fmt.Sprintf("%d", id), "end", ""))
	}()

	var buffer bytes.Buffer

	for e := range ch {
		id++
		buffer.Reset()
		if err := json.NewEncoder(&buffer).Encode(e); err != nil {
			return
		}

		if err := pusher.Push(sse.NewMessage(fmt.Sprintf("%d", id), "data", buffer.String())); err != nil {
			return
		}
	}
}


func writeError(resp io.Writer, err error) {
	switch e := err.(type) {
	case *Error:
		{
			json.NewEncoder(resp).Encode(e)
		}
	default:
		writeError(resp, &Error{
			Code:    0,
			Message: "something unknown happens",
			Cause:   err,
		})
	}
}

func writeResults(out io.Writer) func(...any) {
	return func(rets ...any) {
		w, isHttpWriter := out.(http.ResponseWriter)

		if isHttpWriter {
			w.Header().Set("Content-Type", "application/json")
		}

		if len(rets) > 0 && rets[len(rets)-1] != nil {
			if isHttpWriter {
				w.WriteHeader(http.StatusExpectationFailed)
			}
			writeError(out, rets[len(rets)-1].(error))
		}

		if isHttpWriter {
			w.WriteHeader(http.StatusOK)
		}

		json.NewEncoder(out).Encode(struct {
			Result any `json:"result"`
		}{
			Result: rets,
		})
	}
}

func NewHttpHandler(srv Sender) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		req, err := parseRequest(r.Body, r.Header.Get("Content-Type"))
		if err != nil {
			writeError(w, err)
			return
		}

		srv.Send(r.Context(), req, w)
	})
}

func NewHttpClient(endpoint string, client *http.Client) Sender {
	if client == nil {
		client = http.DefaultClient
	}
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		httpReq.Header.Set("Content-Type", req.ContentType)

		httpResp, err := http.DefaultClient.Do(httpReq)
		if err != nil {
			writeError(resp, err)
			return
		}
		defer httpResp.Body.Close()

		if httpResp.StatusCode != http.StatusOK {
			writeError(resp, fmt.Errorf("unexpected status code: %d", httpResp.StatusCode))
			return
		}

		io.Copy(resp, httpResp.Body)
	})
}



func parseRequest(r io.Reader, contentType string) (*Request, error) {
	req := new(Request)

	switch contentType {
	case "application/json":
		{
			if err := json.NewDecoder(r).Decode(req); err != nil {
				return nil, err
			}
		}
	case "multipart/form-data":
		{
			boundary := strings.TrimPrefix(contentType, "multipart/form-data; boundary=")
			if boundary == "" {
				return nil, errors.New("missing boundary")
			}
			req.Boundary = boundary

			reader := multipart.NewReader(r, boundary)

			for {
				part, err := reader.NextPart()
				if errors.Is(err, io.EOF) {
					break
				} else if err != nil {
					return nil, err
				}

				switch part.FormName() {
				case "id":
					{
						data, err := io.ReadAll(part)
						if err != nil {
							return nil, fmt.Errorf("failed to read multipart id: %w", err)
						}
						req.Id = string(data)
					}
				case "method":
					{
						data, err := io.ReadAll(part)
						if err != nil {
							return nil, fmt.Errorf("failed to read multipart method: %w", err)
						}
						req.Method = string(data)
					}
				case "params":
					{
						data, err := io.ReadAll(part)
						if err != nil {
							return nil, fmt.Errorf("failed to read multipart params: %w", err)
						}
						req.Params = data
					}
				case "file":
					{
						req.Files = append(req.Files, part)
					}
				default:
					{
						return nil, fmt.Errorf("unknown multipart field: %s", part.FormName())
					}
				}
			}
		}
	}

	req.ContentType = contentType

	return req, nil
}

//
// Error
//

type Error struct {
	Code    int64  `json:"code"`
	Message string `json:"message"`
	Cause   error  `json:"cause,omitempty"`
}

var _ error = (*Error)(nil)

func (e *Error) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("%d: %s: %v", e.Code, e.Message, e.Cause)
	}
	return fmt.Sprintf("%d: %s", e.Code, e.Message)
}

func (e Error) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(*Error); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.Cause, target)
}

func (e Error) Unwrap() error {
	return e.Cause
}

func (e Error) WithCause(cause error) *Error {
	err := e
	err.Cause = cause
	return &err
}

func (e Error) WithMsg(msg string, args ...any) *Error {
	err := e
	err.Message = fmt.Sprintf(msg, args...)
	return &err
}

func (e *Error) MarshalJSON() ([]byte, error) {
	payload := struct {
		Error struct {
			Code    int64  `json:"code"`
			Message string `json:"message"`
			Cause   string `json:"cause,omitempty"`
		} `json:"error"`
	}{}

	payload.Error.Code = e.Code
	payload.Error.Message = e.Message
	if e.Cause != nil {
		payload.Error.Cause = e.Cause.Error()
	}

	return json.Marshal(payload)
}

func (e *Error) UnmarshalJSON(data []byte) error {
	wrapper := struct {
		Error json.RawMessage `json:"error"`
	}{}

	if err := json.Unmarshal(data, &wrapper); err != nil {
		return err
	}

	if bytes.Index(wrapper.Error, []byte("{")) == 0 {
		return json.Unmarshal(wrapper.Error, e)
	}

	e.Message = string(wrapper.Error)
	e.Code = 0
	e.Cause = nil

	return nil
}

func newError(code int64, format string, args ...any) *Error {
	return &Error{
		Code:    code,
		Message: fmt.Sprintf(format, args...),
	}
}