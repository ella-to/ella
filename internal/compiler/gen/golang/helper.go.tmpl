{{- define "helpers" }}

type Request struct {
	Id          string            `json:"id"`
	Method      string            `json:"method"`
	Params      json.RawMessage   `json:"params"`
	ContentType string            `json:"-"`
	Files       []*multipart.Part `json:"-"`
	Boundary    string            `json:"-"`
}

type Sender interface {
	Send(ctx context.Context, req *Request, resp io.Writer)
}

type SenderFunc func(ctx context.Context, req *Request, resp io.Writer)

var _ Sender = (*SenderFunc)(nil)

func (f SenderFunc) Send(ctx context.Context, req *Request, resp io.Writer) {
	f(ctx, req, resp)
}

type Registererer interface {
	Register(name string, sender Sender)
}

//

type Registry struct {
	senders map[string]Sender
}

var (
	_ Registererer = (*Registry)(nil)
	_ Sender       = (*Registry)(nil)
)

func (r *Registry) Register(name string, sender Sender) {
	r.senders[name] = sender
}

func (r *Registry) Send(ctx context.Context, req *Request, resp io.Writer) {
	sender, ok := r.senders[req.Method]
	if !ok {
		writeError(resp, &Error{
			Code:    0,
			Message: "method not found",
		})
		return
	}
	sender.Send(ctx, req, resp)
}

func parseParams[A any](r io.Reader) (a A, err error) {
	err = json.NewDecoder(r).Decode(&a)
	return
}

{{ range $size, $_ := .Json2Json }}
func handleJsonToJson{{ $size }}[{{ GenArgsGenerics $size }}](fn func(context.Context, A) ({{ GenReturnsGenerics $size }})) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		writeResults(resp)(fn(ctx, params))
	})
}
{{ end }}

{{ if .Json2Binary }}
func handleJsonToBinary[A any](fn func(context.Context, A) (io.Reader, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		r, err := fn(ctx, params)
		if err != nil {
			writeError(resp, err)
			return
		}

		if w, ok := resp.(http.ResponseWriter); ok {
			w.WriteHeader(http.StatusOK)
			// TODO: change the content type later
			w.Header().Set("Content-Type", "application/octet-stream")
		}

		io.Copy(resp, r)
	})
}
{{ end }}

{{ if .Json2SSE }}
func handleJsonToSSE[A, R any](fn func(context.Context, A) (<-chan R, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		var err error

		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		ch, err := fn(ctx, params)
		if err != nil {
			writeError(resp, err)
			return
		}

		streamEvents(ch, resp)
	})
}
{{ end }}

{{ range $size, $_ := .Binary2Json }}
func handleBinaryToJson{{ $size }}[{{ GenArgsGenerics $size }}](fn func(context.Context, A, func() (string, io.Reader, error)) ({{ GenReturnsGenerics $size }})) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		idx := 0
		writeResults(resp)(fn(ctx, params, func() (string, io.Reader, error) {
			if idx >= len(req.Files) {
				return "", nil, io.EOF
			}

			part := req.Files[idx]
			idx++

			return part.FileName(), part, nil
		}))
	})
}
{{ end }}

{{ if .Binary2Binary }}
func handleBinaryToBinary[A any](fn func(context.Context, A, func() (string, io.Reader, error)) (io.Reader, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			writeError(resp, err)
			return
		}

		idx := 0
		r, err := fn(ctx, params, func() (string, io.Reader, error) {
			if idx >= len(req.Files) {
				return "", nil, io.EOF
			}

			part := req.Files[idx]
			idx++

			return part.FileName(), part, nil
		})
		if err != nil {
			writeError(resp, err)
			return
		}

		if w, ok := resp.(http.ResponseWriter); ok {
			w.WriteHeader(http.StatusOK)
			// TODO: change the content type later
			w.Header().Set("Content-Type", "application/octet-stream")
		}

		io.Copy(resp, r)
	})
}
{{ end }}

{{ if .Binary2SSE }}
func handleBinaryToSSE[A, R any](fn func(context.Context, A, func() (string, io.Reader, error)) (<-chan R, error)) Sender {
	return SenderFunc(func(ctx context.Context, req *Request, resp io.Writer) {
		var err error

		params, err := parseParams[A](bytes.NewReader(req.Params))
		if err != nil {
			return
		}

		idx := 0
		ch, err := fn(ctx, params, func() (string, io.Reader, error) {
			if idx >= len(req.Files) {
				return "", nil, io.EOF
			}

			part := req.Files[idx]
			idx++

			return part.FileName(), part, nil
		})
		if err != nil {
			return
		}

		streamEvents(ch, resp)
	})
}
{{ end }}

{{ if or .Json2SSE .Binary2SSE }}
func streamEvents[T any](ch <-chan T, resp io.Writer) {
	var id int64
	pusher, err := sse.NewPusher(resp, 500*time.Millisecond)
	if err != nil {
		writeError(resp, err)
		return
	}

	defer func() {
		pusher.Close()
		id++

		if err != nil {
			var sb strings.Builder
			writeError(&sb, err)
			pusher.Push(sse.NewMessage(fmt.Sprintf("%d", id), "error", sb.String()))
			id++
		}

		pusher.Push(sse.NewMessage(fmt.Sprintf("%d", id), "end", ""))
	}()

	var buffer bytes.Buffer

	for e := range ch {
		id++
		buffer.Reset()
		if err := json.NewEncoder(&buffer).Encode(e); err != nil {
			return
		}

		if err := pusher.Push(sse.NewMessage(fmt.Sprintf("%d", id), "data", buffer.String())); err != nil {
			return
		}
	}
}
{{ end }}

func writeError(resp io.Writer, err error) {
	switch e := err.(type) {
	case *Error:
		{
			json.NewEncoder(resp).Encode(e)
		}
	default:
		writeError(resp, &Error{
			Code:    0,
			Message: "something unknown happens",
			Cause:   err,
		})
	}
}

func writeResults(out io.Writer) func(...any) {
	return func(rets ...any) {
		w, isHttpWriter := out.(http.ResponseWriter)

		if isHttpWriter {
			w.Header().Set("Content-Type", "application/json")
		}

		if len(rets) > 0 && rets[len(rets)-1] != nil {
			if isHttpWriter {
				w.WriteHeader(http.StatusExpectationFailed)
			}
			writeError(out, rets[len(rets)-1].(error))
		}

		if isHttpWriter {
			w.WriteHeader(http.StatusOK)
		}

		json.NewEncoder(out).Encode(struct {
			Result any `json:"result"`
		}{
			Result: rets,
		})
	}
}

func NewHttpHandler(srv Sender) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		req, err := parseRequest(r.Body, r.Header.Get("Content-Type"))
		if err != nil {
			writeError(w, err)
			return
		}

		srv.Send(r.Context(), req, w)
	})
}

func parseRequest(r io.Reader, contentType string) (*Request, error) {
	req := new(Request)

	switch contentType {
	case "application/json":
		{
			if err := json.NewDecoder(r).Decode(req); err != nil {
				return nil, err
			}
		}
	case "multipart/form-data":
		{
			boundary := strings.TrimPrefix(contentType, "multipart/form-data; boundary=")
			if boundary == "" {
				return nil, errors.New("missing boundary")
			}
			req.Boundary = boundary

			reader := multipart.NewReader(r, boundary)

			for {
				part, err := reader.NextPart()
				if errors.Is(err, io.EOF) {
					break
				} else if err != nil {
					return nil, err
				}

				switch part.FormName() {
				case "id":
					{
						data, err := io.ReadAll(part)
						if err != nil {
							return nil, fmt.Errorf("failed to read multipart id: %w", err)
						}
						req.Id = string(data)
					}
				case "method":
					{
						data, err := io.ReadAll(part)
						if err != nil {
							return nil, fmt.Errorf("failed to read multipart method: %w", err)
						}
						req.Method = string(data)
					}
				case "params":
					{
						data, err := io.ReadAll(part)
						if err != nil {
							return nil, fmt.Errorf("failed to read multipart params: %w", err)
						}
						req.Params = data
					}
				case "file":
					{
						req.Files = append(req.Files, part)
					}
				default:
					{
						return nil, fmt.Errorf("unknown multipart field: %s", part.FormName())
					}
				}
			}
		}
	}

	req.ContentType = contentType

	return req, nil
}

//
// Error
//

type Error struct {
	Code    int64  `json:"code"`
	Message string `json:"message"`
	Cause   error  `json:"cause,omitempty"`
}

var _ error = (*Error)(nil)

func (e *Error) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("%d: %s: %v", e.Code, e.Message, e.Cause)
	}
	return fmt.Sprintf("%d: %s", e.Code, e.Message)
}

func (e Error) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(*Error); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.Cause, target)
}

func (e Error) Unwrap() error {
	return e.Cause
}

func (e Error) WithCause(cause error) *Error {
	err := e
	err.Cause = cause
	return &err
}

func (e Error) WithMsg(msg string, args ...any) *Error {
	err := e
	err.Message = fmt.Sprintf(msg, args...)
	return &err
}

func (e *Error) MarshalJSON() ([]byte, error) {
	payload := struct {
		Error struct {
			Code    int64  `json:"code"`
			Message string `json:"message"`
			Cause   string `json:"cause,omitempty"`
		} `json:"error"`
	}{}

	payload.Error.Code = e.Code
	payload.Error.Message = e.Message
	if e.Cause != nil {
		payload.Error.Cause = e.Cause.Error()
	}

	return json.Marshal(payload)
}

func (e *Error) UnmarshalJSON(data []byte) error {
	wrapper := struct {
		Error json.RawMessage `json:"error"`
	}{}

	if err := json.Unmarshal(data, &wrapper); err != nil {
		return err
	}

	if bytes.Index(wrapper.Error, []byte("{")) == 0 {
		return json.Unmarshal(wrapper.Error, e)
	}

	e.Message = string(wrapper.Error)
	e.Code = 0
	e.Cause = nil

	return nil
}

func newError(code int64, format string, args ...any) *Error {
	return &Error{
		Code:    code,
		Message: fmt.Sprintf(format, args...),
	}
}

{{- end }}